<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MAT276 Slope Field + Table Sampler (t,y)</title>

  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

  <!-- math.js for parsing/evaluating f(t,y) -->
  <script defer src="https://cdn.jsdelivr.net/npm/mathjs@11.11.2/lib/browser/math.js"></script>

  <style>
    :root { --bg:#0f1115; --panel:#171a21; --ink:#e8ecf1; --muted:#aab3c2; --accent:#7aa2ff; --line:#2a2f3a; }
    html,body { height:100%; }
    body {
      margin:0; background:var(--bg); color:var(--ink);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 16px; }
    h1 { margin: 0 0 12px; font-size: 18px; font-weight: 650; }
    .grid { display:grid; grid-template-columns: 380px 1fr; gap: 14px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .card {
      background: var(--panel); border: 1px solid var(--line);
      border-radius: 12px; padding: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,.25);
    }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    label { display:block; color:var(--muted); font-size: 12px; margin-bottom: 6px; }
    input, select, button, textarea {
      width:100%; box-sizing:border-box;
      background:#0e1016; color:var(--ink);
      border:1px solid #2b3240; border-radius:10px;
      padding:10px 10px; outline:none;
    }
    input:focus, textarea:focus, select:focus { border-color: rgba(122,162,255,.7); }
    button {
      cursor:pointer; font-weight:650;
      background: linear-gradient(180deg, rgba(122,162,255,.25), rgba(122,162,255,.12));
      border-color: rgba(122,162,255,.35);
    }
    button:hover { filter: brightness(1.06); }
    .two { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .three { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    .small { font-size: 12px; color: var(--muted); }
    .katexBox {
      padding: 10px 12px; border-radius: 10px;
      border:1px dashed #2b3240; background:#0e1016;
      overflow:auto;
    }
    canvas {
      width: 100%; height: 520px;
      border-radius: 12px; border:1px solid var(--line);
      background: #0b0d12;
      display:block;
    }
    .tableWrap {
      max-height: 520px; overflow:auto; border-radius: 12px;
      border:1px solid var(--line);
    }
    table { width:100%; border-collapse: collapse; min-width: 520px; }
    thead th {
      position: sticky; top:0;
      background:#111520; color: var(--muted);
      text-align:left; font-weight:650; font-size:12px;
      border-bottom: 1px solid var(--line);
      padding: 10px 10px;
      z-index: 2;
    }
    tbody td {
      padding: 9px 10px; border-bottom:1px solid #1f2430;
      font-variant-numeric: tabular-nums;
    }
    .pill {
      display:inline-block; padding: 3px 8px; border-radius: 999px;
      border:1px solid #2b3240; color: var(--muted); font-size: 12px;
      background:#0e1016;
    }
    .warn { color:#ffcc66; }
    .err { color:#ff6b6b; white-space: pre-wrap; }
  </style>
</head>

<body>
<div class="wrap">
  <h1>MAT276 Slope Field (t,y) + Solution Table Sampler</h1>

  <div class="grid">
    <!-- Controls -->
    <div class="card">
      <div style="margin-bottom:10px;">
        <label>ODE right-hand side <span class="small">(type f(t,y))</span></label>
        <input id="fInput" value="t - y" spellcheck="false" />
        <div class="small" style="margin-top:6px;">
          Use <span class="pill">t</span> and <span class="pill">y</span>.
          Functions: <span class="pill">sin</span> <span class="pill">cos</span> <span class="pill">tan</span>
          <span class="pill">exp</span> <span class="pill">log</span> <span class="pill">sqrt</span> <span class="pill">abs</span>.
          Exponent: <span class="pill">^</span> works.
        </div>
      </div>

      <div style="margin-bottom:10px;">
        <label>Rendered math</label>
        <div class="katexBox" id="mathBox"></div>
      </div>

      <div class="two" style="margin-bottom:10px;">
        <div>
          <label>t-min</label>
          <input id="tMin" type="number" step="any" value="0" />
        </div>
        <div>
          <label>t-max</label>
          <input id="tMax" type="number" step="any" value="10" />
        </div>
      </div>

      <div class="two" style="margin-bottom:10px;">
        <div>
          <label>y-min</label>
          <input id="yMin" type="number" step="any" value="-5" />
        </div>
        <div>
          <label>y-max</label>
          <input id="yMax" type="number" step="any" value="5" />
        </div>
      </div>

      <div class="three" style="margin-bottom:10px;">
        <div>
          <label>Grid (t)</label>
          <input id="nT" type="number" min="5" max="80" value="25" />
        </div>
        <div>
          <label>Grid (y)</label>
          <input id="nY" type="number" min="5" max="80" value="25" />
        </div>
        <div>
          <label>Segment scale</label>
          <input id="segScale" type="number" step="any" value="0.9" />
        </div>
      </div>

      <hr style="border:none;border-top:1px solid var(--line); margin: 12px 0;">

      <div class="two" style="margin-bottom:10px;">
        <div>
          <label>Initial condition \(y(t_0)=y_0\)</label>
          <div class="two">
            <input id="t0" type="number" step="any" value="0" title="t0">
            <input id="y0" type="number" step="any" value="1" title="y0">
          </div>
        </div>
        <div>
          <label>Method</label>
          <select id="method">
            <option value="euler">Euler</option>
            <option value="heun">Improved Euler (Heun)</option>
            <option value="rk4" selected>RK4</option>
          </select>
        </div>
      </div>

      <div class="two" style="margin-bottom:10px;">
        <div>
          <label>Compute step \(h\) <span class="small">(internal)</span></label>
          <input id="h" type="number" step="any" value="0.01" />
        </div>
        <div>
          <label>Stop at \(t=\)</label>
          <input id="tEnd" type="number" step="any" value="10" />
        </div>
      </div>

      <div class="two" style="margin-bottom:10px;">
        <div>
          <label>Max table rows</label>
          <input id="maxRows" type="number" min="10" max="5000" value="100" />
        </div>
        <div>
          <label>Display step <span class="small">(optional)</span></label>
          <input id="hDisplay" type="number" step="any" placeholder="auto" />
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="drawBtn" style="flex:1;">Draw slope field</button>
        <button id="solveBtn" style="flex:1;">Compute table</button>
      </div>

      <div id="status" class="small" style="margin-top:10px;"></div>
      <div id="error" class="err" style="margin-top:8px;"></div>
    </div>

    <!-- Canvas + Table -->
    <div class="card">
      <canvas id="canvas" width="1000" height="520"></canvas>
      <div class="row" style="justify-content:space-between; margin-top:10px;">
        <div class="small">
          <span class="pill">Tip</span> If the field looks too dense, reduce Grid (t)/(y). If lines are too long, reduce Segment scale.
        </div>
        <div class="small" id="tableMeta"></div>
      </div>

      <div class="tableWrap" style="margin-top:10px;">
        <table>
          <thead>
            <tr>
              <th style="width:33%;">t</th>
              <th style="width:33%;">y</th>
              <th style="width:34%;">f(t,y)</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<script>
(function () {
  const $ = (id) => document.getElementById(id);

  // Wait until both KaTeX and math.js are available (they load defer)
  function whenReady(fn) {
    const timer = setInterval(() => {
      if (window.katex && window.math) { clearInterval(timer); fn(); }
    }, 20);
  }

  // ---------- Safe KaTeX rendering ----------
  function renderMath(fStr) {
    const box = $("mathBox");
    const latex = String.raw`\frac{dy}{dt} = ${toLatexSafe(fStr)}`;
    try {
      katex.render(latex, box, {
        throwOnError: false,
        displayMode: true,
        strict: "ignore"
      });
    } catch (e) {
      // If KaTeX itself fails, show plain text instead of “black boxes”
      box.textContent = `dy/dt = ${fStr}`;
    }
  }

  // Convert a plain expression to a KaTeX-friendly string.
  // This is intentionally conservative: it avoids injecting raw slashes/HTML.
  function toLatexSafe(expr) {
    // Minimal escaping for KaTeX:
    // - wrap in \text{...} if weird characters appear
    // - otherwise allow typical math characters
    const s = String(expr).trim();
    // Allow digits/letters/operators/paren/space/dot/comma/caret
    const ok = /^[0-9a-zA-Z_\s\+\-\*\/\^\(\)\.,]+$/.test(s);
    if (!ok) return String.raw`\text{${s.replace(/[{}\\]/g, "")}}`;
    // Replace * with \cdot for nicer display (optional)
    return s.replace(/\*/g, String.raw`\cdot `);
  }

  // ---------- Parser / evaluator ----------
  // Uses math.js compile + evaluate for speed and stability.
  // Supports: t, y, common functions, ^ exponent, etc.
  function compileRHS(raw) {
    const expr = preprocess(raw);
    // Will throw if invalid
    return math.compile(expr);
  }

  function preprocess(raw) {
    let s = String(raw || "").trim();

    // Common student inputs:
    // - allow "ln" as log
    // - allow "e^x" (math.js supports e as constant)
    s = s.replace(/\bln\b/gi, "log");

    // Normalize unicode minus
    s = s.replace(/\u2212/g, "-");

    // math.js already supports ^ for exponent
    return s;
  }

  function evalRHS(compiled, t, y) {
    const v = compiled.evaluate({ t, y });
    if (!Number.isFinite(v)) throw new Error("f(t,y) evaluated to a non-finite number.");
    return v;
  }

  // ---------- Canvas mapping ----------
  function makeMapper(tMin, tMax, yMin, yMax, W, H, pad=40) {
    const x0 = pad, y0 = pad;
    const w = W - 2*pad, h = H - 2*pad;

    const tx = (t) => x0 + (t - tMin) * (w / (tMax - tMin));
    const ty = (y) => y0 + (yMax - y) * (h / (yMax - yMin)); // invert
    const invT = (x) => tMin + (x - x0) * ((tMax - tMin) / w);
    const invY = (yy) => yMax - (yy - y0) * ((yMax - yMin) / h);

    return { tx, ty, invT, invY, pad, x0, y0, w, h };
  }

  function drawAxes(ctx, map, tMin, tMax, yMin, yMax) {
    ctx.save();
    ctx.strokeStyle = "#2a2f3a";
    ctx.lineWidth = 1;

    // Border
    ctx.strokeRect(map.x0, map.y0, map.w, map.h);

    // Light grid lines (5 each)
    const n = 5;
    for (let i=1;i<n;i++){
      const x = map.x0 + (map.w*i/n);
      const y = map.y0 + (map.h*i/n);
      ctx.beginPath(); ctx.moveTo(x, map.y0); ctx.lineTo(x, map.y0+map.h); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(map.x0, y); ctx.lineTo(map.x0+map.w, y); ctx.stroke();
    }

    // Labels
    ctx.fillStyle = "#aab3c2";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`t: [${tMin}, ${tMax}]`, map.x0, map.y0 - 10);
    ctx.fillText(`y: [${yMin}, ${yMax}]`, map.x0 + 140, map.y0 - 10);

    ctx.restore();
  }

  // ---------- Slope field ----------
  function drawSlopeField() {
    $("error").textContent = "";
    const ctx = $("canvas").getContext("2d");
    const W = $("canvas").width, H = $("canvas").height;

    const fStr = $("fInput").value;
    const tMin = parseFloat($("tMin").value);
    const tMax = parseFloat($("tMax").value);
    const yMin = parseFloat($("yMin").value);
    const yMax = parseFloat($("yMax").value);
    const nT = Math.max(5, Math.min(80, parseInt($("nT").value, 10) || 25));
    const nY = Math.max(5, Math.min(80, parseInt($("nY").value, 10) || 25));
    const segScale = Math.max(0.1, Math.min(2.0, parseFloat($("segScale").value) || 0.9));

    if (!(tMax > tMin) || !(yMax > yMin)) {
      $("error").textContent = "Please ensure t-max > t-min and y-max > y-min.";
      return;
    }

    let compiled;
    try {
      compiled = compileRHS(fStr);
    } catch (e) {
      $("error").textContent = "Could not parse f(t,y). " + (e && e.message ? e.message : String(e));
      return;
    }

    // Clear
    ctx.clearRect(0, 0, W, H);
    const map = makeMapper(tMin, tMax, yMin, yMax, W, H);
    drawAxes(ctx, map, tMin, tMax, yMin, yMax);

    // Segment base length based on spacing
    const dt = (tMax - tMin) / (nT - 1);
    const dy = (yMax - yMin) / (nY - 1);
    // Convert a "data step" to pixels to set segment length nicely
    const pxDt = Math.abs(map.tx(tMin + dt) - map.tx(tMin));
    const pxDy = Math.abs(map.ty(yMin + dy) - map.ty(yMin));
    const L = segScale * 0.45 * Math.min(pxDt, pxDy);

    ctx.save();
    ctx.strokeStyle = "#7aa2ff";
    ctx.lineWidth = 1;

    for (let i=0; i<nT; i++) {
      const t = tMin + i*dt;
      for (let j=0; j<nY; j++) {
        const y = yMin + j*dy;

        let m;
        try {
          m = evalRHS(compiled, t, y);
        } catch {
          continue;
        }

        // direction vector proportional to (1, m), normalized
        const norm = Math.hypot(1, m);
        const ux = 1 / norm;
        const uy = m / norm;

        const xC = map.tx(t);
        const yC = map.ty(y);

        const x1 = xC - (L * ux);
        const y1 = yC + (L * uy); // + because canvas y goes down
        const x2 = xC + (L * ux);
        const y2 = yC - (L * uy);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }

    // Initial condition point
    const t0 = parseFloat($("t0").value);
    const y0 = parseFloat($("y0").value);
    if (Number.isFinite(t0) && Number.isFinite(y0)) {
      const x0 = map.tx(t0), yy0 = map.ty(y0);
      ctx.fillStyle = "#ffcc66";
      ctx.beginPath(); ctx.arc(x0, yy0, 4, 0, Math.PI*2); ctx.fill();
    }

    ctx.restore();
    $("status").innerHTML = `<span class="pill">Slope field drawn</span> using f(t,y) = <span class="pill">${escapeHtml(fStr)}</span>`;
  }

  // ---------- Numerical methods ----------
  function stepper(method, fCompiled, t, y, h) {
    if (method === "euler") {
      const k1 = evalRHS(fCompiled, t, y);
      return y + h * k1;
    }
    if (method === "heun") {
      const k1 = evalRHS(fCompiled, t, y);
      const yPred = y + h * k1;
      const k2 = evalRHS(fCompiled, t + h, yPred);
      return y + (h/2) * (k1 + k2);
    }
    // rk4 default
    const k1 = evalRHS(fCompiled, t, y);
    const k2 = evalRHS(fCompiled, t + h/2, y + h*k1/2);
    const k3 = evalRHS(fCompiled, t + h/2, y + h*k2/2);
    const k4 = evalRHS(fCompiled, t + h, y + h*k3);
    return y + (h/6) * (k1 + 2*k2 + 2*k3 + k4);
  }

  // Build a full computed trajectory with internal step h,
  // then sample it for display so we cap at maxRows.
  function computeTable() {
    $("error").textContent = "";
    const tbody = $("tbody");
    tbody.innerHTML = "";

    const fStr = $("fInput").value;
    let fCompiled;
    try { fCompiled = compileRHS(fStr); }
    catch (e) {
      $("error").textContent = "Could not parse f(t,y). " + (e && e.message ? e.message : String(e));
      return;
    }

    const method = $("method").value;
    const t0 = parseFloat($("t0").value);
    const y0 = parseFloat($("y0").value);
    const h = parseFloat($("h").value);
    const tEnd = parseFloat($("tEnd").value);
    const maxRows = Math.max(10, parseInt($("maxRows").value, 10) || 100);

    if (!Number.isFinite(t0) || !Number.isFinite(y0) || !Number.isFinite(h) || !Number.isFinite(tEnd)) {
      $("error").textContent = "Please provide numeric values for t0, y0, h, and tEnd.";
      return;
    }
    if (h <= 0) {
      $("error").textContent = "Compute step h must be > 0.";
      return;
    }
    if (!(tEnd > t0)) {
      $("error").textContent = "Please ensure tEnd > t0 (forward integration).";
      return;
    }

    const totalSteps = Math.ceil((tEnd - t0) / h);
    // Determine display step:
    // If user sets it, respect it (but still cap rows by skipping if needed).
    // If blank, auto choose a display step so rows <= maxRows.
    const hDisplayRaw = $("hDisplay").value.trim();
    let hDisplay = hDisplayRaw ? parseFloat(hDisplayRaw) : NaN;

    if (!Number.isFinite(hDisplay) || hDisplay <= 0) {
      // Auto: choose a multiple of h so we show <= maxRows rows.
      const approxEvery = Math.max(1, Math.ceil(totalSteps / (maxRows - 1)));
      hDisplay = approxEvery * h;
    } else {
      // Snap display step to at least h, and to a multiple of h for clean sampling
      const mult = Math.max(1, Math.round(hDisplay / h));
      hDisplay = mult * h;
    }

    // Compute full path but only keep sampled points
    const sampleEvery = Math.max(1, Math.round(hDisplay / h));
    let t = t0;
    let y = y0;

    const rows = [];
    for (let n = 0; n <= totalSteps; n++) {
      if (n % sampleEvery === 0 || n === totalSteps) {
        const ft = safeEvalForRow(fCompiled, t, y);
        rows.push({ t, y, f: ft });
        if (rows.length >= maxRows) break; // hard cap
      }
      // step forward unless last
      if (n < totalSteps) {
        const yNext = stepper(method, fCompiled, t, y, h);
        t = t + h;
        y = yNext;
      }
    }

    // Render rows
    const fmt = (x) => {
      if (!Number.isFinite(x)) return "—";
      // nicer compact format
      const abs = Math.abs(x);
      if (abs !== 0 && (abs < 1e-4 || abs > 1e6)) return x.toExponential(6);
      return (Math.round(x * 1e8) / 1e8).toString();
    };

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${fmt(r.t)}</td><td>${fmt(r.y)}</td><td>${fmt(r.f)}</td>`;
      tbody.appendChild(tr);
    }

    $("tableMeta").textContent =
      `rows: ${rows.length} • internal h=${h} • displayed every ${sampleEvery} step(s) (h_display≈${hDisplay})`;

    $("status").innerHTML =
      `<span class="pill">Table computed</span> using <span class="pill">${escapeHtml(method.toUpperCase())}</span> and f(t,y)=<span class="pill">${escapeHtml(fStr)}</span>`;
  }

  function safeEvalForRow(compiled, t, y) {
    try { return evalRHS(compiled, t, y); }
    catch { return NaN; }
  }

  // ---------- Helpers ----------
  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    })[c]);
  }

  // ---------- Wire up ----------
  whenReady(() => {
    const rerender = () => renderMath($("fInput").value);

    $("fInput").addEventListener("input", rerender);
    $("drawBtn").addEventListener("click", () => { rerender(); drawSlopeField(); });
    $("solveBtn").addEventListener("click", () => { rerender(); computeTable(); });

    // Enter-to-run in RHS input
    $("fInput").addEventListener("keydown", (e) => {
      if (e.key === "Enter") { rerender(); drawSlopeField(); }
    });

    // First render
    rerender();
    drawSlopeField();
  });
})();
</script>
</body>
</html>
